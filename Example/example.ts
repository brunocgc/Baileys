import { Boom } from '@hapi/boom'
import NodeCache from '@cacheable/node-cache'
import readline from 'readline'
import makeWASocket, { AnyMessageContent, BinaryInfo, delay, DisconnectReason, encodeWAM, fetchLatestBaileysVersion, makeCacheableSignalKeyStore, waproto as proto, useMultiFileAuthState, WAMessageContent, WAMessageKey } from '../src'
import fs from 'fs'
import P from 'pino'

const logger = P({ timestamp: () => `,"time":"${new Date().toJSON()}"` }, P.destination('./wa-logs.txt'))
logger.level = 'silent'

const usePairingCode = process.argv.includes('--use-pairing-code')

// external map to store retry counts of messages when decryption/encryption fails
// keep this out of the socket itself, so as to prevent a message decryption/encryption loop across socket restarts
const msgRetryCounterCache = new NodeCache()

const onDemandMap = new Map<string, string>()

// Read line interface
const rl = readline.createInterface({ input: process.stdin, output: process.stdout })
const question = (text: string) => new Promise<string>((resolve) => rl.question(text, resolve))

// start a connection
const startSock = async () => {
	const { state, saveCreds } = await useMultiFileAuthState('../baileys_auth_info')
	// fetch latest version of WA Web
	const { version, isLatest } = await fetchLatestBaileysVersion()
	console.log(`using WA v${version.join('.')}, isLatest: ${isLatest}`)

	const sock = makeWASocket({
		version,
		logger,
		auth: {
			creds: state.creds,
			/** caching makes the store faster to send/recv messages */
			keys: makeCacheableSignalKeyStore(state.keys, logger),
		},
		msgRetryCounterCache,
		generateHighQualityLinkPreview: true,
		// ignore all broadcast messages -- to receive the same
		// comment the line below out
		// shouldIgnoreJid: jid => isJidBroadcast(jid),
		// implement to handle retries & poll updates
		getMessage
	})

	// Pairing code for Web clients
	if (usePairingCode && !sock.authState.creds.registered) {
		// todo move to QR event
		const phoneNumber = await question('Please enter your phone number:\n')
		const code = await sock.requestPairingCode(phoneNumber)
		console.log(`Pairing code: ${code}`)
	}

	const sendMessageWTyping = async (msg: AnyMessageContent, jid: string) => {
		await sock.presenceSubscribe(jid)
		await delay(500)

		await sock.sendPresenceUpdate('composing', jid)
		await delay(2000)

		await sock.sendPresenceUpdate('paused', jid)

		await sock.sendMessage(jid, msg)
	}

	// the process function lets you process all events that just occurred
	// efficiently in a batch
	sock.ev.process(
		// events is a map for event name => event data
		async (events) => {
			// something about the connection changed
			// maybe it closed, or we received all offline message or connection opened
			if (events['connection.update']) {
				const update = events['connection.update']
				const { connection, lastDisconnect } = update
				if (connection === 'close') {
					// reconnect if not logged out
					if ((lastDisconnect?.error as Boom)?.output?.statusCode !== DisconnectReason.loggedOut) {
						startSock()
					} else {
						console.log('Connection closed. You are logged out.')
					}
				}

				// WARNING: THIS WILL SEND A WAM EXAMPLE AND THIS IS A ****CAPTURED MESSAGE.****
				// DO NOT ACTUALLY ENABLE THIS UNLESS YOU MODIFIED THE FILE.JSON!!!!!
				// THE ANALYTICS IN THE FILE ARE OLD. DO NOT USE THEM.
				// YOUR APP SHOULD HAVE GLOBALS AND ANALYTICS ACCURATE TO TIME, DATE AND THE SESSION
				// THIS FILE.JSON APPROACH IS JUST AN APPROACH I USED, BE FREE TO DO THIS IN ANOTHER WAY.
				// THE FIRST EVENT CONTAINS THE CONSTANT GLOBALS, EXCEPT THE seqenceNumber(in the event) and commitTime
				// THIS INCLUDES STUFF LIKE ocVersion WHICH IS CRUCIAL FOR THE PREVENTION OF THE WARNING
				const sendWAMExample = false;
				if (connection === 'open' && sendWAMExample) {
					/// sending WAM EXAMPLE
					const {
						header: {
							wamVersion,
							eventSequenceNumber,
						},
						events,
					} = JSON.parse(await fs.promises.readFile("./boot_analytics_test.json", "utf-8"))

					const binaryInfo = new BinaryInfo({
						protocolVersion: wamVersion,
						sequence: eventSequenceNumber,
						events: events
					})

					const buffer = encodeWAM(binaryInfo);

					const result = await sock.sendWAMBuffer(buffer)
				}


				if (update.qr) {
					const website = "https://quickchart.io/qr?text=" + encodeURIComponent(update.qr)
					console.log('QR code received, open in browser:', website)
				}
			}

			// credentials updated -- save them
			if (events['creds.update']) {
				await saveCreds()
			}

			if (events['labels.association']) {
				// console.log(events['labels.association'])
			}


			if (events['labels.edit']) {
				// console.log(events['labels.edit'])
			}

			if (events.call) {
				// console.log('recv call event', events.call)
			}

			// history received
			if (events['messaging-history.set']) {
				const { chats, contacts, messages, isLatest, progress, syncType } = events['messaging-history.set']
				if (syncType === proto.HistorySync.HistorySyncType.ON_DEMAND) {
					// console.log('received on-demand history sync, messages=', messages)
				}
				// console.log(`recv ${chats.length} chats, ${contacts.length} contacts, ${messages.length} msgs (is latest: ${isLatest}, progress: ${progress}%), type: ${syncType}`)
			}

			// received a new message
			if (events['messages.upsert']) {
				const upsert = events['messages.upsert']
				console.log('recv messages ', JSON.stringify(upsert, undefined, 2))

				if (upsert.type === 'notify') {
					for (const msg of upsert.messages) {
						if (msg.message?.conversation || msg.message?.extendedTextMessage?.text) {
							const text = msg.message?.conversation || msg.message?.extendedTextMessage?.text
							if (text == "requestPlaceholder" && !upsert.requestId) {
								const messageId = await sock.requestPlaceholderResend(msg.key)
								// console.log('requested placeholder resync, id=', messageId)
							} else if (upsert.requestId) {
								// console.log('Message received from phone, id=', upsert.requestId, msg)
							}

							if (text == "!jid") {
								try {
									const lid = sock.user;
									const phone = msg.key.remoteJid!.split('@')[0];
									const lidUser = await sock.onWhatsApp(phone);
									console.log('latest id is', lidUser, 'and my lid is', lid);
									await sock!.readMessages([msg.key]);

									if (lidUser && lidUser.length > 0) {
										await sendMessageWTyping({
											text: `Enviado pelo ${msg.key.remoteJid!}\n\nSeu lid: ${JSON.stringify(lidUser[0])}\nMeu lid: ${JSON.stringify(lid)}`
										}, msg.key.remoteJid!);
									} else {
										await sendMessageWTyping({
											text: `Erro ao obter informa√ß√µes do usu√°rio. JID: ${msg.key.remoteJid!}\nMeu lid: ${JSON.stringify(lid)}`
										}, msg.key.remoteJid!);
									}
								} catch (error) {
									console.error('Erro ao processar comando "jid":', error);
									await sendMessageWTyping({
										text: `Erro ao processar comando. JID: ${msg.key.remoteJid!}`
									}, msg.key.remoteJid!);
								}
							}

							if (text == "!lid") {
								try {
									const lid = sock.user;
									const phone = msg.key.remoteJid!.split('@')[0];
									const lidUser = await sock.onWhatsApp(phone);
									console.log('latest id is', lidUser, 'and my lid is', lid);
									await sock!.readMessages([msg.key]);

									// Verificar se lidUser existe e tem pelo menos um elemento
									if (lidUser && lidUser.length > 0) {
										// Usar o lid se existir e n√£o for vazio, caso contr√°rio usar o remoteJid original
										const userLid = undefined;
										const dados: string = (userLid && typeof userLid === 'string' && userLid !== '') ? userLid : msg.key.remoteJid!;
										console.log(`dados ${dados}`);

										await sendMessageWTyping({
											text: `Enviado pelo ${dados}\n\nSeu lid: ${JSON.stringify(lidUser[0])}\nMeu lid: ${JSON.stringify(lid)}`
										}, dados);
									} else {
										console.log('Erro: n√£o foi poss√≠vel obter informa√ß√µes do usu√°rio');
										await sendMessageWTyping({
											text: `Erro ao obter informa√ß√µes do usu√°rio. Usando JID original: ${msg.key.remoteJid!}`
										}, msg.key.remoteJid!);
									}
								} catch (error) {
									console.error('Erro ao processar comando "lid":', error);
									await sendMessageWTyping({
										text: `Erro ao processar comando. Usando JID original: ${msg.key.remoteJid!}`
									}, msg.key.remoteJid!);
								}
							}

							// Teste de lista simplificado
							if (text === "!listtest") {
								try {
									await sock!.readMessages([msg.key]);
									console.log('üß™ Testando m√∫ltiplas variantes de lista...');

									// Teste 1: Lista b√°sica sem especificar listType
									console.log('üìù TESTE 1: Lista b√°sica...');
									const basicList = {
										text: "üß™ *Teste 1: Lista B√°sica*\n\nEscolha uma op√ß√£o:",
										buttonText: "üîΩ Escolher",
										sections: [{
											title: "Op√ß√µes B√°sicas",
											rows: [
												{ title: "‚úÖ Op√ß√£o A", description: "Primeira op√ß√£o", rowId: "basic_a" },
												{ title: "‚úÖ Op√ß√£o B", description: "Segunda op√ß√£o", rowId: "basic_b" }
											]
										}]
									};

									const result1 = await sock.sendMessage(msg.key.remoteJid!, basicList);
									console.log('‚úÖ Teste 1 enviado! ID:', result1?.key?.id);
									await delay(3000);

									// Teste 2: Lista com PRODUCT_LIST expl√≠cito
									console.log('üìù TESTE 2: Lista com PRODUCT_LIST...');
									const productList = {
										text: "üß™ *Teste 2: Product List*\n\nItens dispon√≠veis:",
										buttonText: "üõí Ver Produtos",
										sections: [{
											title: "Produtos",
											rows: [
												{ title: "üì± Produto 1", description: "Smartphone", rowId: "prod_1" },
												{ title: "üíª Produto 2", description: "Notebook", rowId: "prod_2" }
											]
										}]
									};

									// Usar o tipo proto diretamente na mensagem
									const productMessage = {
										...productList,
										listType: proto.Message.ListMessage.ListType.PRODUCT_LIST
									};

									const result2 = await sock.sendMessage(msg.key.remoteJid!, productMessage);
									console.log('‚úÖ Teste 2 enviado! ID:', result2?.key?.id);
									await delay(3000);

									// Teste 3: Lista com footer e title
									console.log('üìù TESTE 3: Lista com footer e title...');
									const titleFooterList = {
										text: "üß™ *Teste 3: Com Title/Footer*\n\nEscolha uma op√ß√£o:",
										title: "Menu de Teste",
										buttonText: "‚ö° Selecionar",
										footer: "Teste com Footer",
										sections: [{
											title: "Op√ß√µes com Title",
											rows: [
												{ title: "üî• Com Title 1", description: "Primeira com title", rowId: "title_1" },
												{ title: "üî• Com Title 2", description: "Segunda com title", rowId: "title_2" }
											]
										}]
									};

									const result3 = await sock.sendMessage(msg.key.remoteJid!, titleFooterList);
									console.log('‚úÖ Teste 3 enviado! ID:', result3?.key?.id);
									await delay(3000);

									// Teste 4: Lista com uma √∫nica row (minimalista)
									console.log('üìù TESTE 4: Lista com uma √∫nica op√ß√£o...');
									const singleRowList = {
										text: "üß™ *Teste 4: Uma Op√ß√£o*\n\nEscolha:",
										buttonText: "üéØ Selecionar",
										sections: [{
											title: "√önica Op√ß√£o",
											rows: [
												{ title: "‚úÖ √önica", description: "Apenas uma op√ß√£o", rowId: "single_1" }
											]
										}]
									};

									const result4 = await sock.sendMessage(msg.key.remoteJid!, singleRowList);
									console.log('‚úÖ Teste 4 enviado! ID:', result4?.key?.id);

									// Resumo dos testes
									setTimeout(async () => {
										await sendMessageWTyping({
											text: `üß™ *Resumo dos Testes Enviados:*\n\n` +
												`‚úÖ Teste 1 (B√°sica): ${result1?.key?.id}\n` +
												`‚úÖ Teste 2 (Product): ${result2?.key?.id}\n` +
												`‚úÖ Teste 3 (Title/Footer): ${result3?.key?.id}\n` +
												`‚úÖ Teste 4 (√önica Op√ß√£o): ${result4?.key?.id}\n\n` +
												`üì± Verifique seu WhatsApp para ver quais apareceram como lista interativa!\n\n` +
												`üîç *Status das Listas:*\n` +
												`‚Ä¢ ViewOnce: Removido ‚úÖ\n` +
												`‚Ä¢ ListType: Convertido para PRODUCT_LIST ‚úÖ\n` +
												`‚Ä¢ Estrutura: listMessage puro ‚úÖ`
										}, msg.key.remoteJid!);
									}, 2000);

								} catch (error) {
									console.error('‚ùå Erro no teste de lista:', error);
									await sendMessageWTyping({
										text: "‚ùå Teste de lista falhou: " + (error instanceof Error ? error.message : 'Erro desconhecido')
									}, msg.key.remoteJid!);
								}
							}

							// Teste individual de lista mais simples
							if (text === "!list") {
								try {
									await sock!.readMessages([msg.key]);
									console.log('üìã Testando lista individual simples...');

									const simpleList = {
										text: "üìã *Menu Principal*\n\nEscolha uma op√ß√£o:",
										buttonText: "üì± Ver Op√ß√µes",
										sections: [{
											title: "üìÇ Menu",
											rows: [
												{ title: "üÜî Ver JID", description: "Obter seu identificador JID", rowId: "get_jid" },
												{ title: "üîó Ver LID", description: "Obter seu identificador LID", rowId: "get_lid" },
												{ title: "üìä Status", description: "Ver status da conex√£o", rowId: "status" },
												{ title: "‚ÑπÔ∏è Sobre", description: "Informa√ß√µes sobre o bot", rowId: "about" }
											]
										}]
									};

									const result = await sock.sendMessage(msg.key.remoteJid!, simpleList);
									console.log('‚úÖ Lista simples enviada! ID:', result?.key?.id);

								} catch (error) {
									console.error('‚ùå Erro na lista simples:', error);
									await sendMessageWTyping({
										text: "‚ùå Lista simples falhou: " + (error instanceof Error ? error.message : 'Erro desconhecido')
									}, msg.key.remoteJid!);
								}
							}

							// Teste de bot√µes interativos
							if (text === "!buttons") {
								try {
									await sock!.readMessages([msg.key]);
									console.log('üîò Testando bot√µes interativos...');

									const buttonsMessage = {
										text: "üîò *Teste de Bot√µes Interativos*\n\nEscolha uma op√ß√£o clicando nos bot√µes abaixo:",
										buttons: [
											{ buttonId: "btn_1", buttonText: { displayText: "‚úÖ Bot√£o 1" }, type: 1 },
											{ buttonId: "btn_2", buttonText: { displayText: "üî• Bot√£o 2" }, type: 1 },
											{ buttonId: "btn_3", buttonText: { displayText: "‚ö° Bot√£o 3" }, type: 1 }
										],
										headerType: 1
									};

									const result = await sock.sendMessage(msg.key.remoteJid!, buttonsMessage);
									console.log('‚úÖ Bot√µes enviados! ID:', result?.key?.id);

								} catch (error) {
									console.error('‚ùå Erro no teste de bot√µes:', error);
									await sendMessageWTyping({
										text: "‚ùå Teste de bot√µes falhou: " + (error instanceof Error ? error.message : 'Erro desconhecido')
									}, msg.key.remoteJid!);
								}
							}

							// Teste de poll/enquete
							if (text === "!poll") {
								try {
									await sock!.readMessages([msg.key]);
									console.log('üìä Testando poll/enquete...');

									const pollMessage = {
										name: "üó≥Ô∏è Enquete de Teste",
										values: [
											"üçï Pizza",
											"üçî Hamb√∫rguer",
											"üåÆ Taco",
											"üç£ Sushi"
										],
										selectableCount: 1
									};

									const result = await sock.sendMessage(msg.key.remoteJid!, { poll: pollMessage });
									console.log('‚úÖ Poll enviado! ID:', result?.key?.id);

									// Confirma√ß√£o de sucesso
									setTimeout(async () => {
										await sendMessageWTyping({
											text: `üéâ *Poll Enviado com Sucesso!*\n\n` +
												`üìä ID: ${result?.key?.id}\n\n` +
												`‚úÖ *DESCOBERTA IMPORTANTE:*\n` +
												`‚Ä¢ Polls/Enquetes FUNCIONAM! üéØ\n` +
												`‚Ä¢ Listas interativas N√ÉO funcionam ‚ùå\n` +
												`‚Ä¢ Bot√µes interativos N√ÉO funcionam ‚ùå\n\n` +
												`üí° *Conclus√£o:*\n` +
												`Use polls como alternativa √†s listas!\n\n` +
												`üîó Para mais testes: !polltest`
										}, msg.key.remoteJid!);
									}, 1000);

								} catch (error) {
									console.error('‚ùå Erro no teste de poll:', error);
									await sendMessageWTyping({
										text: "‚ùå Teste de poll falhou: " + (error instanceof Error ? error.message : 'Erro desconhecido')
									}, msg.key.remoteJid!);
								}
							}

							// Teste m√∫ltiplo de polls como alternativa √†s listas
							if (text === "!polltest") {
								try {
									await sock!.readMessages([msg.key]);
									console.log('üó≥Ô∏è Testando m√∫ltiplos polls como alternativa √†s listas...');

									// Poll 1: Menu Principal (substituto da lista)
									const menuPoll = {
										name: "üìã Menu Principal - Escolha uma op√ß√£o:",
										values: [
											"üÜî Ver meu JID",
											"üîó Ver meu LID",
											"üìä Status do Bot",
											"‚ÑπÔ∏è Informa√ß√µes"
										],
										selectableCount: 1
									};

									const result1 = await sock.sendMessage(msg.key.remoteJid!, { poll: menuPoll });
									console.log('‚úÖ Poll Menu enviado! ID:', result1?.key?.id);
									await delay(2000);

									// Poll 2: Teste de funcionalidades
									const funcPoll = {
										name: "üß™ Teste de Funcionalidades:",
										values: [
											"üìù Teste de Listas",
											"üîò Teste de Bot√µes",
											"üìä Teste de Polls",
											"üîç Diagn√≥stico Completo"
										],
										selectableCount: 1
									};

									const result2 = await sock.sendMessage(msg.key.remoteJid!, { poll: funcPoll });
									console.log('‚úÖ Poll Funcionalidades enviado! ID:', result2?.key?.id);
									await delay(2000);

									// Poll 3: Prefer√™ncias (m√∫ltipla escolha)
									const prefPoll = {
										name: "üéØ Suas prefer√™ncias (m√∫ltipla escolha):",
										values: [
											"üçï Pizza",
											"üçî Hamb√∫rguer",
											"üåÆ Taco",
											"üç£ Sushi",
											"ü•ó Salada"
										],
										selectableCount: 3 // Permitir m√∫ltiplas sele√ß√µes
									};

									const result3 = await sock.sendMessage(msg.key.remoteJid!, { poll: prefPoll });
									console.log('‚úÖ Poll Prefer√™ncias enviado! ID:', result3?.key?.id);

									// Resumo
									setTimeout(async () => {
										await sendMessageWTyping({
											text: `üó≥Ô∏è *Testes de Polls Conclu√≠dos!*\n\n` +
												`‚úÖ Poll Menu: ${result1?.key?.id}\n` +
												`‚úÖ Poll Funcionalidades: ${result2?.key?.id}\n` +
												`‚úÖ Poll Prefer√™ncias: ${result3?.key?.id}\n\n` +
												`üéØ *Como usar Polls como alternativa:*\n` +
												`‚Ä¢ Use polls para menus de navega√ß√£o\n` +
												`‚Ä¢ Permita sele√ß√£o √∫nica ou m√∫ltipla\n` +
												`‚Ä¢ Capture as respostas nos eventos\n` +
												`‚Ä¢ Polls aparecem como interativos! ‚úÖ\n\n` +
												`üìä Vote nos polls acima para testar!`
										}, msg.key.remoteJid!);
									}, 3000);

								} catch (error) {
									console.error('‚ùå Erro no teste de polls m√∫ltiplos:', error);
									await sendMessageWTyping({
										text: "‚ùå Teste de polls m√∫ltiplos falhou: " + (error instanceof Error ? error.message : 'Erro desconhecido')
									}, msg.key.remoteJid!);
								}
							}

							// Comando de diagn√≥stico completo
							if (text === "!diagnostic") {
								try {
									await sock!.readMessages([msg.key]);
									console.log('üîç Executando diagn√≥stico completo...');
									await sendMessageWTyping({
										text: `üîç *Diagn√≥stico Completo do Bot*\n\n` +
											`üì± *Informa√ß√µes da Conex√£o:*\n` +
											`‚Ä¢ Status: Conectado ‚úÖ\n` +
											`‚Ä¢ JID do Chat: ${msg.key.remoteJid!}\n` +
											`‚Ä¢ Vers√£o Baileys: ${await fetchLatestBaileysVersion().then(v => v.version.join('.'))}\n` +
											`‚Ä¢ User ID: ${JSON.stringify(sock.user?.id || 'N/A')}\n\n` +
											`üß™ *Testes Dispon√≠veis:*\n` +
											`‚Ä¢ !listtest - 4 variantes de lista ‚ùå\n` +
											`‚Ä¢ !list - Lista simples ‚ùå\n` +
											`‚Ä¢ !listfix - Lista com corre√ß√£o viewOnce üîß\n` +
											`‚Ä¢ !buttons - Bot√µes interativos ‚ùå\n` +
											`‚Ä¢ !poll - Enquete/Poll ‚úÖ\n` +
											`‚Ä¢ !polltest - M√∫ltiplos polls ‚úÖ\n\n` +
											`üîß *Configura√ß√µes Ativas (ATUALIZADAS):*\n` +
											`‚Ä¢ Remo√ß√£o ViewOnce: ATIVA ‚úÖ\n` +
											`‚Ä¢ Convers√£o para SINGLE_SELECT: ATIVA ‚úÖ\n` +
											`‚Ä¢ Limpeza DeviceSentMessage: ATIVA ‚úÖ\n` +
											`‚Ä¢ Logs detalhados: Ativos ‚úÖ\n\n` +
											`üéØ *DESCOBERTAS IMPORTANTES:*\n` +
											`‚Ä¢ ‚úÖ Polls/Enquetes: FUNCIONAM!\n` +
											`‚Ä¢ üîß Listas: Testando corre√ß√£o viewOnce\n` +
											`‚Ä¢ ‚ùå Bot√µes: N√£o aparecem como interativos\n` +
											`‚Ä¢ ‚úÖ Mensagens texto: Funcionam\n\n` +
											`üí° *Teste a corre√ß√£o:*\n` +
											`Use !listfix para testar a lista corrigida!\n\n` +
											`üîó *Alternativa confi√°vel:*\n` +
											`!poll e !polltest funcionam perfeitamente!\n\n` +
											`üåç *Poss√≠veis Causas das Limita√ß√µes:*\n` +
											`‚Ä¢ Pol√≠tica do WhatsApp para contas pessoais\n` +
											`‚Ä¢ Restri√ß√µes regionais do Brasil\n` +
											`‚Ä¢ Limita√ß√µes da API n√£o-oficial\n` +
											`‚Ä¢ Mudan√ßas recentes no protocolo WhatsApp`
									}, msg.key.remoteJid!);

								} catch (error) {
									console.error('‚ùå Erro no diagn√≥stico:', error);
									await sendMessageWTyping({
										text: "‚ùå Diagn√≥stico falhou: " + (error instanceof Error ? error.message : 'Erro desconhecido')
									}, msg.key.remoteJid!);
								}
							}

							// Teste de resposta a bot√£o (existente) - substituir por vers√£o consolidada
							if (msg.message?.buttonsResponseMessage?.selectedButtonId) {
								const buttonId = msg.message.buttonsResponseMessage.selectedButtonId;
								await sock!.readMessages([msg.key]);

								console.log('üîò Resposta do bot√£o recebida:', buttonId);

								switch (buttonId) {
									case "btn_jid":
										const lid = sock.user;
										const phone = msg.key.remoteJid!.split('@')[0];
										const lidUser = await sock.onWhatsApp(phone);
										await sendMessageWTyping({
											text: `üÜî *Bot√£o JID Selecionado:*\n\n` +
												`üì± JID: ${msg.key.remoteJid!}\n` +
												`üîó LID: ${JSON.stringify(lidUser && lidUser.length > 0 ? lidUser[0] : 'N/A')}`
										}, msg.key.remoteJid!);
										break;

									case "btn_lid":
										const myLid = sock.user;
										await sendMessageWTyping({
											text: `üîó *Bot√£o LID Selecionado:*\n\n` +
												`ü§ñ Bot LID: ${JSON.stringify(myLid)}`
										}, msg.key.remoteJid!);
										break;

									case "btn_status":
										await sendMessageWTyping({
											text: `üìä *Bot√£o Status Selecionado:*\n\n` +
												`‚úÖ Bot funcionando via bot√µes!`
										}, msg.key.remoteJid!);
										break;

									// Novos bot√µes dos testes
									case "btn_1":
										await sendMessageWTyping({
											text: "‚úÖ Voc√™ clicou no *Bot√£o 1*!\n\nParab√©ns! Os bot√µes est√£o funcionando!"
										}, msg.key.remoteJid!);
										break;
									case "btn_2":
										await sendMessageWTyping({
											text: "üî• Voc√™ clicou no *Bot√£o 2*!\n\nBoa escolha! Sistema responsivo!"
										}, msg.key.remoteJid!);
										break;
									case "btn_3":
										await sendMessageWTyping({
											text: "‚ö° Voc√™ clicou no *Bot√£o 3*!\n\n√ìtimo! Intera√ß√£o confirmada!"
										}, msg.key.remoteJid!);
										break;

									default:
										await sendMessageWTyping({
											text: `üîò Bot√£o selecionado: ${buttonId}`
										}, msg.key.remoteJid!);
								}
							}

							// Resposta ao poll (melhorada)
							if (msg.message?.pollUpdateMessage) {
								await sock!.readMessages([msg.key]);
								console.log('üìä Resposta do poll recebida:', JSON.stringify(msg.message.pollUpdateMessage, null, 2));

								// Tentar extrair a escolha do usu√°rio
								const pollUpdate = msg.message.pollUpdateMessage;
								let selectedOption = "Escolha detectada";

								// Capturar detalhes da vota√ß√£o se dispon√≠vel
								try {
									const vote = pollUpdate.vote;
									if (vote && (vote as any).selectedOptions) {
										const voteIndex = (vote as any).selectedOptions[0];
										if (typeof voteIndex === 'number') {
											selectedOption = `Op√ß√£o ${voteIndex + 1}`;
										}
									}
								} catch (error) {
									console.log('Erro ao extrair op√ß√£o do poll:', error);
								}

								await sendMessageWTyping({
									text: `üìä *Poll/Enquete Respondida!*\n\n` +
										`‚úÖ Sua escolha: ${selectedOption}\n` +
										`üéØ Obrigado por participar!\n\n` +
										`üìà *Status dos Polls:*\n` +
										`‚Ä¢ Funcionalidade: CONFIRMADA ‚úÖ\n` +
										`‚Ä¢ Interatividade: FUNCIONA ‚úÖ\n` +
										`‚Ä¢ Captura de respostas: ATIVA ‚úÖ\n\n` +
										`üí° *Polls s√£o a solu√ß√£o ideal para menus interativos!*\n\n` +
										`üß™ Teste mais: !polltest`
								}, msg.key.remoteJid!);
							}

							// Resposta para sele√ß√£o de lista
							if (msg.message?.listResponseMessage) {
								const selectedOption = msg.message.listResponseMessage.singleSelectReply?.selectedRowId;
								console.log('üéØ Lista selecionada:', selectedOption);

								if (selectedOption) {
									let responseText = "";

									if (selectedOption.startsWith("fixed_")) {
										const fixedNumber = selectedOption.split("_")[1];
										switch (fixedNumber) {
											case "1":
												responseText = "üõ†Ô∏è *ViewOnce Removido Selecionado!*\n\n‚úÖ SUCESSO! A lista interativa funcionou!\n\nO wrapper viewOnceMessage foi removido corretamente e a lista apareceu como interativa no WhatsApp!";
												break;
											case "2":
												responseText = "üéØ *Tipo Corrigido Selecionado!*\n\n‚úÖ FUNCIONOU! A convers√£o do listType foi aplicada corretamente!\n\nA lista foi convertida para SINGLE_SELECT e apareceu como interativa!";
												break;
											case "3":
												responseText = "üì± *Estrutura Limpa Selecionada!*\n\n‚úÖ PERFEITO! A estrutura da mensagem est√° funcionando!\n\nA remo√ß√£o do aninhamento desnecess√°rio permitiu que a lista funcionasse corretamente!";
												break;
											default:
												responseText = `üîß Corre√ß√£o selecionada: ${selectedOption}`;
										}
									} else if (selectedOption.startsWith("option_")) {
										const optionNumber = selectedOption.split("_")[1];
										responseText = `‚úÖ Voc√™ escolheu a *Op√ß√£o ${optionNumber}*!\n\nEssa foi sua sele√ß√£o da lista. Legal!`;
									} else if (selectedOption.startsWith("menu_")) {
										const menuOption = selectedOption.split("_")[1];
										switch (menuOption) {
											case "1":
												responseText = "üìã Voc√™ escolheu *Listar Comandos*!\n\nComandos dispon√≠veis:\n‚Ä¢ !list\n‚Ä¢ !listtest\n‚Ä¢ !listfix\n‚Ä¢ !buttons\n‚Ä¢ !poll\n‚Ä¢ !diagnostic";
												break;
											case "2":
												responseText = "‚ÑπÔ∏è Voc√™ escolheu *Sobre o Bot*!\n\nEste √© um bot de teste do Baileys para WhatsApp.";
												break;
											case "3":
												responseText = "‚öôÔ∏è Voc√™ escolheu *Configura√ß√µes*!\n\nConfigura√ß√µes atuais:\n‚Ä¢ Logs: Ativados\n‚Ä¢ Patches: Ativados\n‚Ä¢ ViewOnce: Removido";
												break;
											default:
												responseText = `‚úÖ Voc√™ escolheu: ${selectedOption}`;
										}
									} else {
										responseText = `‚úÖ Voc√™ escolheu: ${selectedOption}`;
									}

									await sendMessageWTyping({ text: responseText }, msg.key.remoteJid!);
								}
							}
						}
					}
				}
			}

			// messages updated like status delivered, message deleted etc.
			if (events['messages.update']) {
				/* console.log(
					JSON.stringify(events['messages.update'], undefined, 2)
				) */

				for (const { key, update } of events['messages.update']) {
					if (update.pollUpdates) {
						const pollCreation: proto.IMessage = {} // get the poll creation message somehow
						if (pollCreation) {
							/* console.log(
								'got poll update, aggregation: ',
								getAggregateVotesInPollMessage({
									message: pollCreation,
									pollUpdates: update.pollUpdates,
								})
							) */
						}
					}
				}
			}

			/*
			if(events['message-receipt.update']) {
				console.log(events['message-receipt.update'])
			}

			if(events['messages.reaction']) {
				console.log(events['messages.reaction'])
			}

			if(events['presence.update']) {
				console.log(events['presence.update'])
			}

			if(events['chats.update']) {
				console.log(events['chats.update'])
			}
			*/

			if (events['contacts.update']) {
				for (const contact of events['contacts.update']) {
					if (typeof contact.imgUrl !== 'undefined') {
						const newUrl = contact.imgUrl === null
							? null
							: await sock!.profilePictureUrl(contact.id!, 'preview', 30000).catch(() => null)
						/* console.log(
							`contact ${contact.id} has a new profile pic: ${newUrl}`,
						) */
					}
				}
			}

			if (events['chats.delete']) {
				// console.log('chats deleted ', events['chats.delete'])
			}
		}
	)

	return sock

	async function getMessage(key: WAMessageKey): Promise<WAMessageContent | undefined> {
		// Implement a way to retreive messages that were upserted from messages.upsert
		// up to you

		// only if store is present
		return proto.Message.fromObject({})
	}
}

startSock()
